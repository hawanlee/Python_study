# 正则表达式
## 编写一个正则表达式的模式
### 使用简单的模式
/abc/  
匹配一个字符串中出现'abc'且按照这个顺序
### 使用特殊的字符

<table>
  <tr>
    <th style="width: 100px;">符号</th>
    <th>含义</th>
  </tr>
  <tr>
    <td>\</td>
    <td>1. 在非特殊字符前的反斜杠表示下一个字符是特殊的，不能从字面上解释，意思是匹配一个字符边界；<br>
    1. 反斜杠也可以将其后的特殊字符转为字面量，如/a*/代表匹配0或多个a，/a\*/将*的特殊性移除，表示匹配'a*'这样的字符串。反斜杠本身也是也是一个转义字符</td>
  </tr>
  <tr>
    <td>^</td>
    <td>匹配输入的开始，如果多行标志被设置为true，那么也会匹配换行符后紧跟的位置。如/^A/会匹配‘ABC’，不会匹配‘BAC’。当^作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。</td>
  </tr>
  <tr>
    <td>$</td>
    <td>匹配输入的结束。如果多行标示被设置为true，那么也匹配换行符前的位置。
    例如，/t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。</td>
  </tr>
  <tr>
    <td>*</td>
    <td>匹配前一个表达式0次或多次。等价于 {0,}。

例如，/bo*/会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中将不会匹配任何东西。</td>
  </tr>
  <tr>
    <td>+</td>
    <td>匹配前面一个表达式1次或者多次。等价于 {1,}。<br>
    例如，/a+/匹配了在 "candy" 中的 'a'，和在 "caaaaaaandy" 中所有的 'a'。</td>
  </tr>
  <tr>
    <td>?</td>
    <td>匹配前面一个表达式0次或者1次。等价于 {0,1}。<br>
    例如，/e?le?/ 匹配 "angel" 中的 'el'，和 "angle" 中的 'le' 以及"oslo' 中的'l'。<br>
    如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。<br>
    例如，对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。<br>
    还可以运用于先行断言，如本表的 x(?=y) 和 x(?!y) 条目中所述</td>
  </tr>
  <tr>
    <td>.</td>
    <td>（小数点）匹配除换行符之外的任何单个字符。<br>
    例如，/.n/将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。</td>
  </tr>
  <tr>
    <td>(x)</td>
    <td>匹配 'x' 并且记住匹配项，就像下面的例子展示的那样。括号被称为 捕获括号。<br>
    模式/(foo) (bar) \1 \2/中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中前两个单词。模式中的 \1 和 \2 匹配字符串的后两个单词。注意 \1、\2、\n 是用在正则表达式的匹配环节。在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。</td>
  </tr>
  <tr>
    <td>(?:x)</td>
    <td>匹配 'x' 但是不记住匹配项。这种叫作非捕获括号，使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词</td>
  </tr>
  <tr>
    <td>x(?=y)</td>
    <td>例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</td>
  </tr>
  <tr>
    <td>(?<=y)x</td>
    <td>匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。<br>
    例如，/(?<=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。/(?<=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</td>
  </tr>
  <tr>
    <td>x(?!y)</td>
    <td>匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。<br>
    例如，/\d+(?!\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’而不是‘3.141’</td>
  </tr>
  <tr>
    <td>x|y</td>
    <td>匹配‘x’或者‘y’。<br>
    例如，/green|red/匹配“green apple”中的‘green’和“red apple”中的‘red’</td>
  </tr>
  <tr>
    <td>{n}</td>
    <td>n是一个正整数，匹配了前面一个字符刚好发生了n次。<br>
    比如，/a{2}/不会匹配“candy”中的'a',但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个'a'。</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td></td>
    <td></td>
  </tr>
</table>